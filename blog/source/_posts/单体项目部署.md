---
title: Java项目部署
excerpt: 比较简单的单体项目部署方式
categories:
  - 运维
index_img: https://img0.baidu.com/it/u=3705150710,3501402283&fm=253&fmt=auto&app=138&f=PNG?w=500&h=288
abbrlink: ea92c0b9
date: 2021-05-03 21:04:56
---
# 一、安装Nginx
## (一)Docker安装nginx
### 1.查看镜像版本

```sh
docker  search nginx
```

### 2.拉取镜像

```
docker pull nginx
```

### 3.查看镜像

```
docker images | grep nginx
```

### 4.创建挂载目录

```
mkdir nginx
cd nginx
mkdir conf
mkdir wwwroot
mkdir logs
```
```sh
#创建挂载目录
mkdir -p ./nginx/{conf,html,logs}
```

### 5.构建容器并启动

```
docker run -d --name=nginx -p 80:80 \
-v /local/docker/nginx/wwwroot:/usr/share/nginx/html \
-v /local/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
-v /local/docker/nginx/logs:/var/log/nginx \
nginx
```

## （二）

### 1.安装依赖包

```
sudo yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel
```

### 2.下载并解压安装包

```
cd /usr/local//下载tar包
sudo wget  http://nginx.org/download/nginx-1.21.4.tar.gz
sudo tar -xvf nginx-1.21.4.tar.gz
```

https://www.cnblogs.com/gezp/p/14967445.html

### 启动

```
# 检查配置文件
sudo /usr/local/nginx/sbin/nginx  -t
#启动
sudo /usr/local/nginx/sbin/nginx
# 重启加载配置
sudo /usr/local/nginx/sbin/nginx -s reload
```



# 配置文件

```sh
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {

	#博客服务器，多个可以实现负载均衡
    upstream sob-blog{
	   server 172.23.152.88:8082 weight=1;
    }


 
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

   
	server {
		listen       80;
		server_name  localhost;

		#charset koi8-r;
		#access_log  /var/log/nginx/host.access.log  main;
		
		index index.html index.htm index.php;
		#用户相关的请求，转到sob-blog
		location ^~/user/ {
            	proxy_pass   http://sob-blog;
			#以下是一些反向代理的配置可删除
			proxy_redirect             off; 
			#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
			proxy_set_header           Host $host;
			proxy_set_header 		   Cookie $http_cookie;
			proxy_set_header           X-Real-IP $remote_addr; 
			proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
			proxy_set_header           X-Forwarded-Server $host;
        }
        
		location ^~/admin/ {
           	proxy_pass   http://sob-blog;
			#以下是一些反向代理的配置可删除
			proxy_redirect             off; 
			#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
			proxy_set_header           Host $host;
			proxy_set_header 		   Cookie $http_cookie;
			proxy_set_header           X-Real-IP $remote_addr; 
			proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
			proxy_set_header           X-Forwarded-Server $host;
        }
        
        location ^~/portal/ {
           	proxy_pass   http://sob-blog;
			#以下是一些反向代理的配置可删除
			proxy_redirect             off; 
			#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
			proxy_set_header           Host $host;
			proxy_set_header 		   Cookie $http_cookie;
			proxy_set_header           X-Real-IP $remote_addr; 
			proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
			proxy_set_header           X-Forwarded-Server $host;
        }

		#其他访问访问根目录wwwroot
		location / {
		    root   /usr/share/nginx/html;
		    index  index.html index.htm;
		    #此处解决刷新页面出现404的问题
		    try_files $uri $uri/ /index.html;
        }
		
	}
}

```



```shell
#user  nobody;
 
#==工作进程数，一般设置为cpu核心数
worker_processes  1;
 
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
 
#pid        logs/nginx.pid;
 
 
events {
 
    #==最大连接数，一般设置为cpu*2048
    worker_connections  1024;
}
 
 
http {

    # 负载均衡配置
    upstream web_servers {
    server localhost:8082;
    }

    include       mime.types;
    default_type  application/octet-stream;
 
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
 
    #access_log  logs/access.log  main;
 
    sendfile        on;
    #tcp_nopush     on;
 
    #keepalive_timeout  0;
    
    #==客户端链接超时时间
    keepalive_timeout  65;
 
    #gzip  on;
 
    #当配置多个server节点时，默认server names的缓存区大小就不够了，需要手动设置大一点
    server_names_hash_bucket_size 512;
 
    #server表示虚拟主机可以理解为一个站点，可以配置多个server节点搭建多个站点
    #每一个请求进来确定使用哪个server由server_name确定
    server {
        #站点监听端口
        listen       80;
        #站点访问域名
        server_name  localhost;
        
        #编码格式，避免url参数乱码
        charset utf-8;
 
        #access_log  logs/host.access.log  main;
 
        #location用来匹配同一域名下多个URI的访问规则
        #比如动态资源如何跳转，静态资源如何跳转等
        #location后面跟着的/代表匹配规则
        location / {
            #站点根目录，可以是相对路径，也可以使绝对路径
            root   html;
            #默认主页
            index  index.html index.htm;
            
            #转发后端站点地址，一般用于做软负载，轮询后端服务器
            #proxy_pass http://ip:端口;
 
            #拒绝请求，返回403，一般用于某些目录禁止访问
            #deny all;
            
            #允许请求
            #allow all;
            
            add_header 'Access-Control-Allow-Origin' '*';
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
            add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';
            #重新定义或者添加发往后端服务器的请求头
            #给请求头中添加客户请求主机名
            proxy_set_header Host $host;
            #给请求头中添加客户端IP
            proxy_set_header X-Real-IP $remote_addr;
            #将$remote_addr变量值添加在客户端“X-Forwarded-For”请求头的后面，并以逗号分隔。 如果客户端请求未携带“X-Forwarded-For”请求头，$proxy_add_x_forwarded_for变量值将与$remote_addr变量相同  
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            #给请求头中添加客户端的Cookie
            proxy_set_header Cookie $http_cookie;
            #将使用代理服务器的主域名和端口号来替换。如果端口是80，可以不加。
            proxy_redirect off;
            
            #浏览器对 Cookie 有很多限制，如果 Cookie 的 Domain 部分与当前页面的 Domain 不匹配就无法写入。
            #所以如果请求 A 域名，服务器 proxy_pass 到 B 域名，然后 B 服务器输出 Domian=B 的 Cookie，
            #前端的页面依然停留在 A 域名上，于是浏览器就无法将 Cookie 写入。
            
　　         #不仅是域名，浏览器对 Path 也有限制。我们经常会 proxy_pass 到目标服务器的某个 Path 下，
            #不把这个 Path 暴露给浏览器。这时候如果目标服务器的 Cookie 写死了 Path 也会出现 Cookie 无法写入的问题。
            
            #设置“Set-Cookie”响应头中的domain属性的替换文本，其值可以为一个字符串、正则表达式的模式或一个引用的变量
            #转发后端服务器如果需要Cookie则需要将cookie domain也进行转换，否则前端域名与后端域名不一致cookie就会无法存取
　　　　　　  #配置规则：proxy_cookie_domain serverDomain(后端服务器域) nginxDomain(nginx服务器域)
            proxy_cookie_domain localhost .testcaigou800.com;
            
            #取消当前配置级别的所有proxy_cookie_domain指令
            #proxy_cookie_domain off;
            #与后端服务器建立连接的超时时间。一般不可能大于75秒；
            proxy_connect_timeout 30;
        }

        #用户相关的请求，转到sob-blog
		location ^~/user/ {
            proxy_pass   http://web_servers;
			#以下是一些反向代理的配置可删除
			proxy_redirect             off; 
			#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
			proxy_set_header           Host $host;
			proxy_set_header 		   Cookie $http_cookie;
			proxy_set_header           X-Real-IP $remote_addr; 
			proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
			proxy_set_header           X-Forwarded-Server $host;
        }
        
		location ^~/admin/ {
           	 proxy_pass   http://web_servers;
			#以下是一些反向代理的配置可删除
			proxy_redirect             off; 
			#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
			proxy_set_header           Host $host;
			proxy_set_header 		   Cookie $http_cookie;
			proxy_set_header           X-Real-IP $remote_addr; 
			proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
			proxy_set_header           X-Forwarded-Server $host;
        }
        
        location ^~/portal/ {
           	proxy_pass   http://web_servers;
			#以下是一些反向代理的配置可删除
			proxy_redirect             off; 
			#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
			proxy_set_header           Host $host;
			proxy_set_header 		   Cookie $http_cookie;
			proxy_set_header           X-Real-IP $remote_addr; 
			proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
			proxy_set_header           X-Forwarded-Server $host;
        }
 
        #error_page  404              /404.html;
 
        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
 
    }
    
```
# linux服务器上jar包启动及关闭方式
## 1、直接启动
```shell
java -jar chapter.jar
```
> 这种启动方式有个缺点：启动好了之后就不能动了，不能ctrl+c退出，也不能关闭终端，一旦退出或者关闭终端，程序就会关闭。
## 2.后台启动
```shell
java -jar chapter.jar &
```
> &符号就代表后台启动，这种启动方式日志仍然输入到终端控制台中，但是ctrl+c不会关闭程序，退出终端，程序会关闭
## 3.nohup启动
```sh
nohup java -jar chapter.jar &
```
> 这种方式会生成一个nohup.out来记录日志，所以日志不会直接输出到终端，而且这种方式启动，ctrl+c或者关闭终端，程序都不会结束
## 4、指定日志文件
nohup启动的日志输出文件nohup.out是自动生成的，但是我们更希望自己指定日志输出文件，用以下命令：
```sh
nohup java -jar chapter.jar > logs.log &
```
> 此命令会将日志重定向到当前的logs.log文件中，但是只会输出标准输出。这种方式启动，ctrl+c或者关闭终端，程序都不会结束

## 5、重定向错误输出（推荐）
```sh
nohup java -jar chapter.jar > logs.log 2>&1 &
```
> 这条命令不懂的可以去了解一下shell脚本，我简单解释一下：
 Linux下1表示标准输出，2表示错误输出
“>logs.log”表示标准输出重定向到logs.log中，默认是标准输出，省略1,不省略的话可以写成1>logs.log;
"2>&1"表示错误输出也重定向到logs.log中，其中&1表示前面的logs.log文件，不加&，写成2>1的话就表示把错误输出到1这个文件而不是前面标准输出的文件logs.log，所以&要加上；
最后一个&表示以后台方式启动程序。
这种方式启动，ctrl+c或者关闭终端，程序都不会结束。

## 6、以系统服务启动（更推荐）

​     以系统服务启动，实际上就是自己注册一个系统服务，然后系统服务的功能就是启动此jar包，所以我们就可以通过启动自定义系统服务控制jar包的启动了，这种方式有很多好处，最显而易见的就是系统服务的启动、停止、查看状态、开机自启动等命令能直接管理到jar包进程。

1. 创建自定义系统服务(只介绍CentOS7下的方式)
   在/etc/systemd/system目录下创建一个xxx.service文件，xxx就是自定义的服务名称。
   在文件中写入以下内容：

```sh
[Unit]

Description=chapter

After=syslog.target

[Service]

ExecStart=/usr/software/jdk1.8.0_221/bin/java -jar /usr/programme/serviceJarTest/chapter.jar

[Install]

WantedBy=multi-user.target

```

> 内容解释：
> [Unit]说明
> Description:服务的描述
> After:设置在某个服务启动后启动
>
> [Service]服务参数配置
> ExecStart服务运行执行的命令
>
> [Install]服务安装的相关设置，可设置为多用户
>
> 根据需要，自己修改description和ExecStart的内容即可（ExecStart后面的java命令需要全路径，写java -jar 会启动不了）

​	2. 启动系统服务

```sh
systemctl start 服务名
```

```
systemctl start xxx  #启动服务
systemctl status xxx  #查看服务状态
systemctl stop xxx  #停止服务
systemctl enable xxx  #设置服务开机自启动
systemctl disable xxx  #取消服务开机自启动
systemctl restart xxx  #重启服务
```

## 7、关闭jar包程序

- 如果是第一种方式启动，ctrl+c就可以直接关闭


- 如果是第二种方式启动，关闭终端就可以关闭程序


- 如果是第三四五种方式启动，可以用kill进程的方式结束进程：
  查看java进程：

```sh
ps -ef | grep java
#或者
 ps -ef|grep Blog-0.0.1-SNAPSHOT.jar

```

```sh
//关闭进程
#24204为查询出来的进程号
kill -s 9 24204 
```

# 8.启动

```sh
nohup java -Djasypt.encryptor.password=578bee5369c35ad48751dd979ea4681e -Xms512m -Xmx512m -XX:MaxMetaspaceSize=128m  -XX:MaxNewSize=256m -jar  Blog-0.0.1-SNAPSHOT.jar  > logs.log 2>&1 &
```
知识点:
JDK8之后把-XX:PermSize 和-XX:MaxPermGen移除了，取而代之的是
```sh
-XX:MetaspaceSize=128m （元空间默认大小）
-XX:MaxMetaspaceSize=128m （元空间最大大小）
```
参数介绍:
-XX:MetaspaceSize=128m （元空间默认大小）
-XX:MaxMetaspaceSize=128m （元空间最大大小）
-Xms1024m （堆最大大小）
-Xmx1024m （堆默认大小）
-Xmn256m （新生代大小）
-Xss256k （棧最大深度大小）
-XX:SurvivorRatio=8 （新生代分区比例 8:2）
-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）
-XX:+PrintGCDetails （打印详细的GC日志）

